<?php

namespace App\Imports;

use App\Models\Customers\Customer;
use App\Models\Customers\CustomerCreditDebitNote;
use App\Models\Setups\Customers\CustomerType;
use App\Models\Setups\Customers\CustomerGroup;
use App\Models\Setups\Customers\CustomerProvince;
use App\Models\Setups\Customers\CustomerZone;
use App\Models\Setups\Customers\CustomerPaymentTerm;
use App\Models\Employees\Employee;
use App\Models\Items\PriceList;
use App\Models\Setting;
use App\Helpers\CurrencyHelper;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Carbon;
use Maatwebsite\Excel\Concerns\ToCollection;
use Maatwebsite\Excel\Concerns\WithHeadingRow;
use Maatwebsite\Excel\Concerns\WithValidation;
use Maatwebsite\Excel\Concerns\WithBatchInserts;
use Maatwebsite\Excel\Concerns\WithChunkReading;

class CustomersImport implements ToCollection, WithHeadingRow, WithBatchInserts, WithChunkReading
{
    protected $skipDuplicates;
    protected $updateExisting;
    protected $results = [
        'total' => 0,
        'imported' => 0,
        'updated' => 0,
        'skipped' => 0,
        'errors' => []
    ];

    public function __construct($skipDuplicates = false, $updateExisting = false)
    {
        $this->skipDuplicates = $skipDuplicates;
        $this->updateExisting = $updateExisting;
    }

    /**
     * Process each collection/chunk
     */
    public function collection(Collection $rows)
    {
        foreach ($rows as $index => $row) {
            $this->results['total']++;
            $rowNumber = $index + 2; // +2 because of header row and 0-based index

            try {
                // Validate row data
                $result = $this->validateRow($row->toArray(), $rowNumber);

                if (isset($result['error'])) {
                    $this->results['skipped']++;
                    $this->results['errors'][] = [
                        'row' => $rowNumber,
                        'error' => $result['error']
                    ];
                    continue;
                }

                $validatedData = $result['data'];
                $startingBalance = $result['starting_balance'] ?? null;

                // Check for duplicates by code only (allow duplicate names)
                $existingCustomer = null;
                if (!empty($validatedData['code'])) {
                    $existingCustomer = Customer::withTrashed()->where('code', $validatedData['code'])->first();
                }

                // Handle duplicate logic
                if ($existingCustomer) {
                    if ($this->updateExisting) {
                        // Update existing customer
                        $existingCustomer->update($validatedData);
                        $this->results['updated']++;

                        // Don't create starting balance for updated customers
                    } else {
                        // Skip duplicate
                        $this->results['skipped']++;
                        $this->results['errors'][] = [
                            'row' => $rowNumber,
                            'error' => "Customer already exists with code: {$validatedData['code']}"
                        ];
                    }
                } else {
                    // Create new customer
                    // If code is not provided, it will be auto-generated by the model
                    if (empty($validatedData['code'])) {
                        unset($validatedData['code']);
                    }

                    $customer = Customer::create($validatedData);
                    $this->results['imported']++;

                    // Create credit/debit note for starting balance if provided
                    if ($startingBalance !== null && $startingBalance != 0) {
                        $this->createStartingBalanceNote($customer, $startingBalance, $rowNumber);
                    }
                }

            } catch (\Exception $e) {
                $this->results['skipped']++;
                $this->results['errors'][] = [
                    'row' => $rowNumber,
                    'error' => $e->getMessage()
                ];
                Log::error("Row {$rowNumber} processing failed", [
                    'error' => $e->getMessage(),
                    'file' => $e->getFile(),
                    'line' => $e->getLine()
                ]);
            }
        }
    }

    /**
     * Validate and transform row data
     */
    protected function validateRow(array $row, int $rowNumber): array
    {
        // Extract starting balance (if provided)
        $startingBalance = $row['starting_balance'] ?? $row['opening_balance'] ?? null;
        if ($startingBalance !== null && $startingBalance !== '') {
            $startingBalance = (float) $startingBalance;
        } else {
            $startingBalance = null;
        }

        // Map column headers to expected fields
        $data = [
            'code' => $row['code'] ?? $row['customer_code'] ?? null,
            'name' => $row['name'] ?? $row['customer_name'] ?? null,
            'customer_type_id' => null,
            'customer_group_id' => null,
            'customer_province_id' => null,
            'customer_zone_id' => null,
            'current_balance' => 0, // Don't set from CSV, will be calculated via credit/debit notes
            'address' => $row['address'] ?? null,
            'city' => $row['city'] ?? null,
            'telephone' => $row['telephone'] ?? $row['phone'] ?? null,
            'mobile' => $row['mobile'] ?? $row['mobile_number'] ?? null,
            'url' => $row['url'] ?? $row['website'] ?? null,
            'email' => $row['email'] ?? null,
            'contact_name' => $row['contact_name'] ?? $row['contact'] ?? null,
            'gps_coordinates' => $row['gps_coordinates'] ?? $row['gps'] ?? null,
            'mof_tax_number' => $row['mof_tax_number'] ?? $row['tax_number'] ?? null,
            'salesperson_id' => null,
            'customer_payment_term_id' => null,
            'price_list_id_INV' => null,
            'price_list_id_INX' => null,
            'discount_percentage' => $row['discount_percentage'] ?? $row['discount'] ?? 0,
            'credit_limit' => $row['credit_limit'] ?? null,
            'notes' => $row['notes'] ?? $row['remarks'] ?? null,
            'is_active' => isset($row['is_active']) ? filter_var($row['is_active'], FILTER_VALIDATE_BOOLEAN) : true,
            'created_at' => $this->parseDate($row['created_at'] ?? null),
            'total_old_sales' => $row['total_old_sales'] ?? 0,
        ];

        // Required field validation
        if (empty($data['name'])) {
            return ['error' => 'Customer name is required'];
        }

        // Lookup customer type by name or code
        if (!empty($row['customer_type']) || !empty($row['type'])) {
            $typeName = $row['customer_type'] ?? $row['type'];
            $customerType = CustomerType::where('name', $typeName)
                ->first();
            if ($customerType) {
                $data['customer_type_id'] = $customerType->id;
            }
        }

        // Lookup customer group by name or code
        if (!empty($row['customer_group']) || !empty($row['group'])) {
            $groupName = $row['customer_group'] ?? $row['group'];
            $customerGroup = CustomerGroup::where('name', $groupName)
                ->first();
            if ($customerGroup) {
                $data['customer_group_id'] = $customerGroup->id;
            }
        }

        // Lookup customer province by name
        if (!empty($row['customer_province']) || !empty($row['province'])) {
            $provinceName = $row['customer_province'] ?? $row['province'];
            $customerProvince = CustomerProvince::where('name', $provinceName)->first();
            if ($customerProvince) {
                $data['customer_province_id'] = $customerProvince->id;
            }
        }

        // Lookup customer zone by name
        if (!empty($row['customer_zone']) || !empty($row['zone'])) {
            $zoneName = $row['customer_zone'] ?? $row['zone'];
            $customerZone = CustomerZone::where('name', $zoneName)->first();
            if ($customerZone) {
                $data['customer_zone_id'] = $customerZone->id;
            }
        }

        // Lookup salesperson by code or name
        if (!empty($row['salesperson']) || !empty($row['salesperson_code'])) {
            $salespersonIdentifier = $row['salesperson'] ?? $row['salesperson_code'];
            $salesperson = Employee::where('code', $salespersonIdentifier)
                ->orWhere('name', $salespersonIdentifier)
                ->first();
            if ($salesperson) {
                $data['salesperson_id'] = $salesperson->id;
            }
        }

        // Lookup payment term by name or days
        if (!empty($row['payment_term']) || !empty($row['payment_terms'])) {
            $paymentTermName = $row['payment_term'] ?? $row['payment_terms'];
            $paymentTerm = CustomerPaymentTerm::where('name', $paymentTermName)
                ->orWhere('days', $paymentTermName)
                ->first();
            if ($paymentTerm) {
                $data['customer_payment_term_id'] = $paymentTerm->id;
            }
        }

        // Lookup price list INV by code
        if (!empty($row['price_list_inv_code']) || !empty($row['price_list_code_inv'])) {
            $priceListCode = $row['price_list_inv_code'] ?? $row['price_list_code_inv'];
            $priceList = PriceList::where('code', $priceListCode)->first();
            if ($priceList) {
                $data['price_list_id_INV'] = $priceList->id;
            }
        }

        // Lookup price list INX by code
        if (!empty($row['price_list_inx_code']) || !empty($row['price_list_code_inx'])) {
            $priceListCode = $row['price_list_inx_code'] ?? $row['price_list_code_inx'];
            $priceList = PriceList::where('code', $priceListCode)->first();
            if ($priceList) {
                $data['price_list_id_INX'] = $priceList->id;
            }
        }

        // Validate email format if provided
        if (!empty($data['email']) && !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            return ['error' => 'Invalid email format'];
        }

        // Validate URL format if provided
        if (!empty($data['url']) && !filter_var($data['url'], FILTER_VALIDATE_URL)) {
            return ['error' => 'Invalid URL format'];
        }

        // Clean up null values
        $data = array_filter($data, function($value) {
            return $value !== null && $value !== '';
        });

        return [
            'data' => $data,
            'starting_balance' => $startingBalance
        ];
    }

    /**
     * Parse date from various formats
     */
    protected function parseDate($dateValue): ?string
    {
        if (empty($dateValue)) {
            return null;
        }

        try {
            // Handle Excel numeric date format
            if (is_numeric($dateValue)) {
                // Excel dates are stored as number of days since 1900-01-01
                $unix_date = ($dateValue - 25569) * 86400;
                return Carbon::createFromTimestamp($unix_date)->format('Y-m-d H:i:s');
            }

            // Try parsing common date formats
            $formats = [
                'Y-m-d H:i:s',  // 2025-12-22 10:30:00
                'Y-m-d',        // 2025-12-22
                'd-m-Y',        // 22-12-2025
                'd/m/Y',        // 22/12/2025
                'm-d-Y',        // 12-22-2025
                'm/d/Y',        // 12/22/2025
                'd-m-Y H:i:s',  // 22-12-2025 10:30:00
                'd/m/Y H:i:s',  // 22/12/2025 10:30:00
            ];

            foreach ($formats as $format) {
                $date = Carbon::createFromFormat($format, $dateValue);
                if ($date !== false) {
                    return $date->format('Y-m-d H:i:s');
                }
            }

            // Try Carbon's flexible parser as fallback
            return Carbon::parse($dateValue)->format('Y-m-d H:i:s');
        } catch (\Exception $e) {
            // If date parsing fails, log and return null
            Log::warning("Failed to parse date: {$dateValue}", ['error' => $e->getMessage()]);
            return null;
        }
    }

    /**
     * Create credit/debit note for starting balance
     */
    protected function createStartingBalanceNote(Customer $customer, float $startingBalance, int $rowNumber): void
    {
        try {
            // Get default currency
            $defaultCurrencyId = Setting::get('general', 'default_currency', 1);
            if (!$defaultCurrencyId) {
                throw new \Exception('Default currency not configured in settings');
            }

            // Determine type and prefix based on balance
            // Positive balance = customer owes us = debit
            // Negative balance = we owe customer = credit
            $type = $startingBalance < 0 ? 'debit' : 'credit';
            $prefix = $startingBalance < 0 ? 'DBX' : 'CRX';
            $amount = abs($startingBalance);

            // Get currency rate (assuming default currency rate is 1)
            $currencyRate = 1.0;

            // Convert to USD
            $amountUsd = CurrencyHelper::toUsd($defaultCurrencyId, $amount, $currencyRate);

            // Create the credit/debit note
            CustomerCreditDebitNote::create([
                'date' => now(),
                'prefix' => $prefix,
                'type' => $type,
                'customer_id' => $customer->id,
                'currency_id' => $defaultCurrencyId,
                'currency_rate' => $currencyRate,
                'amount' => $amount,
                'amount_usd' => $amountUsd,
                'note' => 'Starting balance from customer import',
            ]);

        } catch (\Exception $e) {
            // Log error but don't fail the import
            $this->results['errors'][] = [
                'row' => $rowNumber,
                'error' => "Customer imported but starting balance note failed: " . $e->getMessage()
            ];
        }
    }

    /**
     * Batch size for bulk inserts
     */
    public function batchSize(): int
    {
        return 100;
    }

    /**
     * Chunk size for reading
     */
    public function chunkSize(): int
    {
        return 100;
    }

    /**
     * Get import results
     */
    public function getResults(): array
    {
        return $this->results;
    }
}
